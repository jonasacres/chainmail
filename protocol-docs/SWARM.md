# Chainmail Swarming

Chainmail is fully peer-to-peer, meaning that blockstore data is communicated directly between peers. This presents a few challenges:

1. Peers should have a means of determining that each other peer possesses at least one public key that has been recorded into an Identity possessing a current Credential record authorizing access to the blockstore.

2. Peers should not be able to match public keys to IPs. For example, if there is a disagreement, it should not be possible to use the swarm network to discover a participant's IP address for retaliation.

3. When someone is kicked out of the community (via key revocation), they should not be able to use the swarm network to continue to observe new blocks and records.

## Establising a connection to a peer

### Step 0: Establish a TCP connection to a peer
The connection process begins by opening a TCP connection to the remote peer. This requires knowing the IP address and port of a peer. This could be done via some means beyond the scope of this draft specification (e.g. telling the other person), or via the DHT protocol described elsewhere in this draft specification.

The peer initiating the TCP connection is described here as `Pb`; the peer receiving the connection is referred to as `Pb`.

### Step 1: Agree to a ciphersuite
The peers must agree on a ciphersuite:

```
Pa: { "crypto":{"sym":["aes_256_gcm"], "asym":["EC_PLACEHOLDER"], "hash":["sha_512-256"], "prng":["hmac_drbg"]}, "swarm":["cmswarm_0"] }
Pb: { "crypto":{"sym":["aes_256_gcm"], "asym":["EC_PLACEHOLDER"], "hash":["sha_512-256"], "prng":["hmac_drbg"]}, "swarm":["cmswarm_0"] }
```

This is a placeholder for future extensions, since the only algorithms supported right now are 256-bit AES in Galois/counter mode, SHA512-256, HMAC-DRBG and a 512-bit elliptic curve-based encryption algorithm that is yet to be determined (TODO). The method for selecting a set of algorithms when multiple options are supported by both peers is undefined. Similarly, the only swarming protocol supported right now is `cmswarm_0`, the protocol described in this draft specification.

### Step 2: Create secure channel

```
// $EphPubKeyA is the public key from an ephemeral keypair generated by Pa. This keypair is NOT the same as the one whose public key is regsitered in the Chainmail community!
// $EphPubKeyB is a similar ephemeral keypair generated by Pb.
// $RandA, $ChallengeA are random numbers selected by Pa, of length equal to the selected hash length (256 bits in this protocol).
// $RandB, $ChallengeB are similar random numbers selected by Pb.
// $Secret is a pre-shared group secret, as recorded in the Protocol record of the blockchain; if omitted, use empty string.
// $HSKey = Hash($RandA || $RandB || $EphPubKeyA || $EphPubKeyB)
// $BID is the blockstore ID of the community being joined
// $BlockCountA is the index of the latest block for which Pa has acquired all relevant Identity, Credential or Revoke records.
// $BlockCountB is the index of the latest block for which Pb has acquired all relevant Identity, Credential or Revoke records.
//
// Enc(key, plaintext) is a function that encrypts the given plaintext with the given key, and returns the ciphertext encoded in Base64.
// A || B is the concatenation of A and B
// Hmac(key, message) is an application of HMAC using the selected hash algorithm.

// Pa and Pb exchange public keys.
Pa: { "pubkey":$EphPubKeyA }
Pb: Enc($EphPubKeyA, {"r":$RandB, "c":$ChallengeB, "pubkey":$EphPubKeyB})

// Pa identifies the group it would like to exchange data for, and proves knowledge of the group secret.
Pa: Enc($EphPubKeyB, {"r":$RandA}) || ":" || Enc($HSKey, {"r":$ChallengeA, "venue":$BID, "secret":Hmac($Secret, Hash($EphPubKeyA) || Hash($EphPubKeyB) || $ChallengeB) })

// Pb proves that it too knows the group secret, and discloses the number of blocks it possesses.
Pb: Enc($HSKey, { "blocks":$BlockCountB, "secret":Hmac($Secret, Hash($EphPubKeyA) || Hash($EphPubKeyB) || $ChallengeA) })

// Pa now discloses how many blocks it possesses as well.
Pa: Enc($HSKey, { "blocks":$BlockCountA })
```

### Step 3: Prove mutual community membership

In the previous step, the peers established a shared secret $HSkey, and exchanged the respective lengths of their copies of the chain. The peer with the longer chain will be designated `P1`; the other peer will be `P2`. If the chains are of equal length, then `Pa` will be `P1`.

```
// $N1, $S1, $R1 are random numbers selected by P1. Their length matches the hash length.
// $N2, $S2, $R2 are similar random numbers selected by P2.
// $BridgeKey = Hash($N1 || $N2 || $HSKey)
// $KeySet is the set of all public keys authorized to receive blockstore data, to the best of P1's knowledge.
// Rosetta(keyset, text) is an array with one entry for each public key ("pkey") in keyset, with the following entry format:
//   [ pkey, Enc(pkey, pad(pkey, text)) ]
// pad(key, text) is a function providing pre- and post-padding to text in a deterministic fashion based solely on the supplied key and text.


P1: Enc($HSKey, { "rosetta":Rosetta($KeySet, $N1), "hash":Hash($N1) })

// P2 proves it has at least one key in P1's rosetta by demonstrating knowledge of $N1. P2 also learns $KeySet from P1's rosetta.
P2: Enc($HSKey, { "rosetta":Rosetta($KeySet, $N2), "hash":Hash($N1 || $N2 || $R2), "rand":$R2 })

// P1 and P2 now both know $N1 and $N2, and can therefore each compute $BridgeKey.
P1: Enc($BridgeKey, {"r":$R1})

// P1 and P2 now both know $R1 and $R2, and can therefore compute a new session key: $SessKey = Hash($R1 || $R2).
```

All future communication is encrypted using `$SessKey`.

## Communicating with a peer
// TODO: These are all rough notes that need to be digested. Pardon the mess! This is generously borrowed from BitTorrent.

enum {
  choke,
  unchoke,
  interested,
  uninterested,
  have,
  bitfield,
  request,
  piece,
  cancel,
  newblock,
  sync,
  renegotiate,
  reestablish
}

struct cm_swarm_have {
  cm_hash record;
  int piece;
}

struct cm_swarm_bitfield {
  cm_hash record;
  char[] bitfield;
}

struct cm_swarm_request {
  cm_hash record;
  int index;
  int begin;
  int length;
}

struct cm_swarm_piece {
  cm_hash record
  int index;
  int begin;
  char[] piece;
}

struct cm_swarm_cancel {
  cm_hash record;
  int index;
  int begin;
  int length;
}

struct cm_swarm_newblock {
  cm_hash blockref;
  int index;
}

struct cm_swarm_sync {
  peer_ref peers[];
  cm_hash last_block;
  int index;
}
```

## Expiration of session keys

Negotiated session keys do not last forever. When a peer accepts a block that alters the set of acceptable public keys (either by adding, removing or modifying a public key), it sends a `renegotiate` message to each connected peer, and invalidates all its session keys. Peers receiving a `renegotiate` then act as the connecting peer on the pre-existing socket to negotiate a new session key, regardless of who originally opened the socket.

Peers also expire session keys after 2 hours, plus a random delay of up to 2 hours, regardless of activity or blocks received.

## Reuse of session keys

In the event that a TCP connection is lost, the peers may attempt to re-open the connection. If the TCP connection is restored, the connecting peer first attempts to reuse its existing session key:

```
Pa: {"keyhash":Hash($SessKey)}

// Session key is still acceptable
Pb: {"valid":true}

// Session key is unacceptable
Pb: {"valid":false}
```

If the key is accepted, the peers resume the protocol in the same state it was in when the connection was lost. (TODO: Not quite the same; re-establish choke and interested, due to lack of certainty of delivery of final packets).

If the key is not accepted, the peers must renegotiate a new session key.
# Chainmail Swarming

Chainmail is fully peer-to-peer, meaning that blockstore data is communicated directly between peers. This presents a few challenges:

1. Peers should have a means of determining that each other peer possesses at least one public key that has been recorded into an Identity possessing a current Credential record authorizing access to the blockstore.

2. Peers should not be able to match public keys to IPs. For example, if there is a disagreement, it should not be possible to use the swarm network to discover a participant's IP address for retaliation.

3. When someone is kicked out of the community (via key revocation), they should not be able to use the swarm network to continue to observe new blocks and records.

## Establising a connection to a peer

### Step 0: Establish a TCP connection to a peer
The connection process begins by opening a TCP connection to the remote peer. This requires knowing the IP address and port of a peer. This could be done via some means beyond the scope of this draft specification (e.g. telling the other person), or via the DHT protocol described elsewhere in this draft specification.

The peer initiating the TCP connection is described here as `Pb`; the peer receiving the connection is referred to as `Pb`.

### Step 1: Agree to a ciphersuite
The peers must agree on a ciphersuite:

```
Pa: { "crypto":{"sym":["aes_256_gcm"], "asym":["EC_PLACEHOLDER"], "hash":["sha_512-256"], "prng":["hmac_drbg"]}, "swarm":["cmswarm_0"] }
Pb: { "crypto":{"sym":["aes_256_gcm"], "asym":["EC_PLACEHOLDER"], "hash":["sha_512-256"], "prng":["hmac_drbg"]}, "swarm":["cmswarm_0"] }
```

This is a placeholder for future extensions, since the only algorithms supported right now are 256-bit AES in Galois/counter mode, SHA512-256, HMAC-DRBG and a 512-bit elliptic curve-based encryption algorithm that is yet to be determined (TODO). The method for selecting a set of algorithms when multiple options are supported by both peers is undefined. Similarly, the only swarming protocol supported right now is `cmswarm_0`, the protocol described in this draft specification.

### Step 2: Create secure channel

```
// $EphPubKeyA is the public key from an ephemeral keypair generated by Pa. This keypair is NOT the same as the one whose public key is regsitered in the Chainmail community!
// $EphPubKeyB is a similar ephemeral keypair generated by Pb.
// $RandA, $ChallengeA are random numbers selected by Pa, of length equal to the selected hash length (256 bits in this protocol).
// $RandB, $ChallengeB are similar random numbers selected by Pb.
// $Secret is a pre-shared group secret, as recorded in the Protocol record of the blockchain; if omitted, use empty string.
// $HSKey = Hash($RandA || $RandB || $EphPubKeyA || $EphPubKeyB)
// $BID is the blockstore ID of the community being joined
// $BlockCountA is the index of the latest block for which Pa has acquired all relevant Identity, Credential or Revoke records.
// $BlockCountB is the index of the latest block for which Pb has acquired all relevant Identity, Credential or Revoke records.
//
// Enc(key, plaintext) is a function that encrypts the given plaintext with the given key, and returns the ciphertext encoded in Base64.
// A || B is the concatenation of A and B
// Hmac(key, message) is an application of HMAC using the selected hash algorithm.

// Pa and Pb exchange public keys.
Pa: { "pubkey":$EphPubKeyA }
Pb: Enc($EphPubKeyA, {"r":$RandB, "c":$ChallengeB, "pubkey":$EphPubKeyB})

// Pa identifies the group it would like to exchange data for, and proves knowledge of the group secret.
Pa: Enc($EphPubKeyB, {"r":$RandA}) || ":" || Enc($HSKey, {"r":$ChallengeA, "venue":$BID, "secret":Hmac($Secret, Hash($EphPubKeyA) || Hash($EphPubKeyB) || $ChallengeB) })

// Pb proves that it too knows the group secret, and discloses the number of blocks it possesses.
Pb: Enc($HSKey, { "blocks":$BlockCountB, "secret":Hmac($Secret, Hash($EphPubKeyA) || Hash($EphPubKeyB) || $ChallengeA) })

// Pa now discloses how many blocks it possesses as well.
Pa: Enc($HSKey, { "blocks":$BlockCountA })
```

The peer with the longer chain will be designated `P1`; the other peer will be `P2`. If the chains are of equal length, then `Pa` will be `P1`.

### Step 3a: Prove mutual community membership (for non-public groups)

For groups not marked public (as defined by the `public` field of the Protocol record) to the best of P1's knowledge, members must mutually demonstrate knowledge of at least one key signed into the group.

```
// $N1, $S1, $R1 are random numbers selected by P1. Their length matches the hash length.
// $N2, $S2, $R2 are similar random numbers selected by P2.
// $BridgeKey = Hash($N1 || $N2 || $HSKey)
// $KeySet is the set of all public keys authorized to receive blockstore data, to the best of P1's knowledge.
// Rosetta(keyset, text) is an array with one entry for each public key ("pkey") in keyset, with the following entry format:
//   [ pkey, Enc(pkey, pad(pkey, text)) ]
// pad(key, text) is a function providing pre- and post-padding to text in a deterministic fashion based solely on the supplied key and text.


P1: Enc($HSKey, { "public":false, "rosetta":Rosetta($KeySet, $N1), "hash":Hash($N1) })

// P2 proves it has at least one key in P1's rosetta by demonstrating knowledge of $N1. P2 also learns $KeySet from P1's rosetta.
P2: Enc($HSKey, { "rosetta":Rosetta($KeySet, $N2), "hash":Hash($N1 || $N2 || $R2), "rand":$R2 })

// P1 and P2 now both know $N1 and $N2, and can therefore each compute $BridgeKey.
P1: Enc($BridgeKey, {"r":$R1})

// P1 and P2 now both know $R1 and $R2 and have demonstrated knowledge of $N1 and $N2, and by extension, proven membership in the group.
// They can now compute a new session key: $SessKey = Hash($R1 || $R2).
```

All future communication is encrypted using `$SessKey`. The notation `Enc($SessKey, ...)` is therefore omitted, and should be considered implied.

### Step 3b: Open communication (for public groups)

If, to the best of P1's knowledge, the group is marked public, P1 will signal that it is willing to exchange blockchain information with P2. In this case, `$HSKey` will be used to encrypt all communication. The notation `Enc($HSKey, ...)` is therefore omitted, and should be considered implied.

```
P1: {"public":true}
```

### Step 4: Resolving disparity

If P1 claims a longer blockchain than P2, then P2 must immediately `choke`, signalling that it will not supply data. P2 may not `unchoke` until it obtains all blocks, and all Identity, Credential, Protocol and Revoke records.

* If P1 claimed the group to be public, P2 has no way of knowing that the group has actually been made public (or remains public) until it obtains the complete blockchain.
* If P1 claimed the group to be non-public, P2 has no way of knowing whether P1 is using a key that remains valid. In fact, P1 might inject a brand new key into the Rosetta that was never granted access inside the blockstore at all.

## Communicating with a peer
// TODO: These are all rough notes that need to be digested. Pardon the mess! This is generously borrowed from BitTorrent.

enum {
  choke,
  unchoke,
  interested,
  uninterested,
  have,
  bitfield,
  request,
  piece,
  cancel,
  newblock,
  sync,
  renegotiate,
  reestablish,
  protocol
}

struct cm_swarm_have {
  cm_hash record;
  int piece;
}

struct cm_swarm_bitfield {
  cm_hash record;
  char[] bitfield;
}

struct cm_swarm_request {
  cm_hash record;
  int index;
  int begin;
  int length;
}

struct cm_swarm_piece {
  cm_hash record
  int index;
  int begin;
  char[] piece;
}

struct cm_swarm_cancel {
  cm_hash record;
  int index;
  int begin;
  int length;
}

struct cm_swarm_newblock {
  cm_hash blockref;
  int index;
}

struct cm_swarm_sync {
  peer_ref peers[];
  cm_hash last_block;
  int index;
}
```

## Expiration of session keys

Negotiated session keys do not last forever. When a peer accepts a block that alters the set of acceptable public keys (either by adding, removing or modifying a public key), it sends a `renegotiate` message to each connected peer, and invalidates all its session keys. Peers receiving a `renegotiate` then act as the connecting peer on the pre-existing socket to negotiate a new session key, regardless of who originally opened the socket.

Peers also expire session keys after 2 hours, plus a random delay of up to 2 hours, regardless of activity or blocks received.

## Reuse of session keys

In the event that a TCP connection is lost, the peers may attempt to re-open the connection. If the TCP connection is restored, the connecting peer first attempts to reuse its existing session key:

```
Pa: {"keyhash":Hash($SessKey), "pubkey":$EphPubKeyA}

// Session key is still acceptable; recap last known state for both parties. Pb's known state as listed in this packet will be the initial state for the new connection.
Pb: { "valid":true, "ct":Enc($SessKey, { "me":{ "choke":true, "interested":true }, "you":{ "choke":true, "interested":false } }) }

// Session key is unacceptable
Pb: Enc($EphPubKeyA, {"r":$RandB, "c":$ChallengeB, "pubkey":$EphPubKeyB})
```

If the key is accepted, the peers resume the protocol in the same state it was in when the connection was lost.

If the key is not accepted, the peers must renegotiate a new session key.